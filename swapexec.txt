	   SwapExec -- Swap memory & execute external routine

  Этот	текст	представляет  собой   краткую  аннотацию   к  использованию
подпрограммы SwapExec -- выгрузки памяти и выполнения внешней программы.


	     Суть используемого метода состоит в следующем:

    Подпрограмма  SwapExec  подключается  при  построении  образа задачи (в
дальнейшем -  Task Image  - TI)  как можно  ближе к  началу TI.  При вызове
данной подпрограммы последняя пытается выполнить следующие шаги:

   1.	Определяет  размер  TI,  подлежащего  выгрузке	на  диск.    Размер
определяется  либо  размером  занятой  TI  памяти,  либо размером TI+размер
свободной памяти выше TI. Это определяется параметрами вызова.

   2. Ищет потенциально доступное место для выгрузки - диск, XMS, EMS

   3. Выполняет  логическое AND  между результатами  поиска и  указанными в
параметрах допустимыми областями для выгрузки.

   4.	Определяет  исходя  из	заданного  приоритета  место  для выгрузки.
Приоритет убывает в  ряду XMS -  EMS - DISK,  либо EMS -  XMS - DISK,  если
задан соответствующий параметр.

   5. Выделяет место и выгружает TI выше себя в указанное пространство.

   6. Запускает внешнюю задачу

   7. Получает ErrorLevel

   8.  Контролирует  память  на  предмет  полного освобождения после вызова
внешней задачи.

   9. Загружает назад TI

  10. Освобождает пространство выгрузки

  11. Проверяет контрольную сумму загруженного

  12. Восстанавливает стек и регистры вызывающей программы и выходит.

   Вы можете получить результат последнего	обращения в текстовом  виде
путем вызова  функции	LastSwapError без  параметров, которая  вернет  вам
указатель на  AsciiZ строку,  содержащую текстовое  сообщение о  результате
последнего вызова SwapExec.  Вызывать эту функцю можно сколько угодно  раз,
в случае  отсутствия ошибок  она вернет  строчку типа  "Success". В  случае
отключения  условной  трансляции  путем  установки  в 0 переменной GetMsg в
разделе  "переменные  условной   трансляции"  файла  SwapExec.Inc,   данная
функция  всегда  возвращает   единственную  зарезервированную  строчку,   и
текстовые строки с сообщениями об ошибках в коде отсутствуют.

   Другая функция  - GetSwapErrorCode  - возвращает  в виде  двойного слова
все  коды  ошибок,  место  последнего  свопа,  и  тип под-кода ошибки, если
таковой  существует.   Рекомендуемый  алгоритм  обработки ошибок следующий:
если  байт  0  слова  равен  нулю,  то  байт  1 содержит код ошибки внешней
процедуры, запущенной через функцию DOS EXEC.  Байт 2 неопределен.   Иначе,
байт  1  содержит  под-код  ошибки,  то  есть  код  ошибки DOS/XMS/EMS либо
неопределен. Узнать, какой именно класс под-ошибки присутствует, можно  при
помощи  байта  2,  в  котором  содержится  одно из Ln_None, Ln_Dos, Ln_Ems,
Ln_Xms. Ну и, наконец, байт 3 всегда сообщает о типе последнего  своппинга,
а именно - Fr_None, Fr_Dsk, Fr_Xms, Fr_Ems.

   В случае каких-либо внешних ошибок или срабатывания контроля  внутренней
непротиворечивости  _ДО_  момента  освобождения  памяти  от  TI, происходит
возврат в вызывающую программу с соответствующим кодом ошибки.

   В случае  ошибок _ПОСЛЕ_  освобождения памяти  от TI  на экран выводится
диагностика  о	фатальной  ошибке,  а  дальнейшие  действия  выполняются  в
зависимости   от   уровня   игнорирования   ошибок,   заданных	в  качестве
параметров:

   Ac_War  -  Warnings	-  Игнорировать  предупреждения.  К предупреждениям
относятся  такие  события,  после  которых  сама  программа  будет работать
нормально, однако окружение DOS находится в непредусмотренном состоянии.  В
основном  это	ошибки	освобождения   пространства  выгрузки.	 Вы  можете
использовать этот режим до выхода очередной исправленной версии  программы,
если вы точно знаете причину появления ошибки.

   Ac_Err  -  Errors  -  Игнорировать  негрубые ошибки. К ошибкам относятся
несовпадения контрольной суммы загруженного назад TI, измененное  состояние
памяти	после  завершения  внешней  задачи  (что  может  иметь	место	при
несанкционированной   загрузке	 TSR'ов)   и   тому   подобное.  Вы  можете
использовать  этот   режим  как   крайнее  средство,   если  в	 результате
неоднократных наблюдений не отмечено неустойчивой работы программы.

   Ac_Sev -  Severe errors  - Игнорировать  грубые ошибки.  К таким ошибкам
относятся грубые  ошибки при  загрузке TI,  ошибки чтения  диска и  т.п. Вы
можете	использовать  этот  режим  как	самое  крайнее	средство при личном
контроле,  если  у  Вас  нет  другого  выхода в то время, как использование
программы  абсолютно  необходимо.  Не  оставляйте  этот  режим	без личного
контроля - вероятность зависания программы составляет > 50% !

   Ac_Fat -  Fatal errors  - Игнорировать  все ошибки.	К фатальным ошибкам
относятся ошибки,  результатом которых	является невозможность	продолжения
работы	программы.   Например,	это  невозможность  открыть  файл временной
выгрузки и как следствие загрузить назад TI. Сюда так же относятся  ошибки,
оставляющие  в	неопределенном	состоянии  внутренние  переменные.  Задание
этого  режима  -  это  99%  гарантия  зависания  программы,  и	вы   можете
попробовать  его  как  последнее  средство  перед  тем	как  отказаться  от
использования ее текущей версии.


			       Примечания:

   1.  Вы  должны  _всегда_  задавать  корректное имя файла своппинга, либо
пустое имя,  даже если	своппинг на  диск запрещен  в параметрах.  Указание
имени  "Ж:\Саня_Пушкин"  будет  всегда  приводить  к  ошибке  - потрудитесь
задать "" вместо него.

   2. Программа  пытается открыть  имя своп-файла  так, как  вы его задали.
Если был  возвращен код  ошибки, то  код функции  DOS заменяется с "Создать
файл" на "Создать  временный файл" и  попытка повторяется. Ошибка  и в этом
случае	 расценивается	 как   неустранимая.   Все   это   позволяет	Вам
указать как конкретное имя файла,  так и путь для  автоматического создания
временного  файла.	Вариант   "C:\ABC"  приведет   к  созданию    файла
"C:\ABC",  либо  к  созданию  временного  файла  в каталоге "C:\ABC\", если
таковой  каталог  уже  имеется.  Если  вторая  попытка	вернула  код ошибки
"неверный путь", то вам будет возвращен код ошибки от первой попытки.

   3. Пустое имя файла запрещает своппинг на диск.

   4. Доступность места на диске для своппинга определяется  предварительно
через  стандартную  функцию  получения	свободного места. Диск определяется
как буква от имени файла, если	вторым символом стоит ":", и как  текущий в
противном случае.

   5.  Выгрузка  возможна  лишь  целиком  в  какое-либо  место,   частичная
выгрузка в  XMS, затем	в EMS,	а остатка  - на  диск --  невозможна. Такое
решение  было  принято	 как  некий  компромисс   между  оптимальностью   и
надежностью. Следует  помнить, что  весь механизм  своппинга реализован  на
ассемблере,  и	чем  короче  он  будет,  тем  лучше  для  повышения   общей
надежности программы. Из тех же соображений не реализован  самоперемещаемый
в начало загрузчик. И без того проблем и тонких мест хватает.

   6. Следует учитывать, что сама идея своппинга нереализуема  стандартными
средствами  DOS  и  не	может  быть  абсолютно корректной по определению. В
данной	программе  предприняты	все   меры  по	минимизации   использования
недокументированных  возможностей  DOS.  Единственное,	без чего не удалось
обойтись,  это	без  вмешательства  в  подсистему распределения памяти DOS.
Вмешательство выполняется максимально  корректно, согласно описанию  блоков
MCB, однако  нельзя гарантировать  100% совместимость  со всеми  версиями и
подверсиями DOS и  разного рода эмуляторами  DOS в многозадачных  системах.
Текущая  версия  тестировалась	в  MS  DOS  5.0  & 6.2, а так же в DOS-окне
системы  OS/2.	Есть  все  основания  предполагать совместимость с DR-DOS и
другими реализациями. Есть так же все основания полагать, что  некорректным
можно  считать	только	сам  процесс  выгрузки,  а  состояние  памяти после
выгрузке  должно  отвечать  правилам,  принятым  в  DOS.  Механизм обратной
загрузки так же использует вмешательство в структуры DOS.

   7. Если Вы  заказываете расширение имени  исполняемого файла до  полного
пути, то  имейте ввиду  что это  делается недокументированной  функцией DOS
60h,   которая   является   аналогом   команды   TrueName    интерпретатора
Command.Com.   Неизвестно,  как  именно  происходит  это  преобразование  в
разного  рода  эмуляторах  DOS  и  на  сетевых  дисках, хотя есть основания
полагать, что  функция должна  работать везде,  ввиду частого использования
внутри самой DOS.

   Автором  программы  своппинга  является  Лихачев Михаил Алексеевич, FIDO
2:5030/131 (Mikle Likhachev), lma@hts.ru, lma@hts.convey.ru.

---------------------------------------------------------------------------
